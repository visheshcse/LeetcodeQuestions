
###########################################################################################################################################################
Time Complexity in recursion Tree
A safe way to express the time complexity:
Number of is_palindrome calls: O(2^n)
Number of is_palindrome calls in GP terms:
********************************************************************
Assume worst case: from each state recursion branches into 2 children
(like “cut here” or “do not cut here”).
Think of the recursion tree levels:
Level 0: 2^0 = 1 node  Level 1: 2^1 = 2 nodes, Level 2: 2^2 = 4 nodes
Level k: 2^k nodes
...
Level n: 2^n nodes (at most)
Total number of nodes (states) in the recursion tree is:
1 + 2 + 4 + ... + 2^n
This is a geometric progression (GP) with
first term a = 1, ratio r = 2, number of terms = n+1.
Sum of GP:
S = a * (r^(n+1) - 1) / (r - 1)
S = 1 * (2^(n+1) - 1) / (2 - 1)
S = 2^(n+1) - 1
Asymptotically, S is O(2^n).
************************************************************************
Each node corresponds to at most a constant number of is_palindrome checks,
so the total number of is_palindrome calls is O(2^n).
Cost per is_palindrome call: O(n)
Total time: O(2^n * n)
Some branches are short and many substrings are smaller than length n, so the actual running time is often less in practice. 
O(2^n * n) is just a worst-case upper bound, not saying that each recursion level always costs O(n)
###########################################################################################################################################################

Recursion Video - Hitesh chai aur code
https://www.youtube.com/watch?v=l8X9nhgZyoA

###########################################################################################################################################################

1.Generate one side of tree only.The end stop will become the base case
2.Draw a tree. Options in a tree become a part of recursive calls.
3.The number of calls depend on number of levels at a particular set of tree, it can be one, two, or many(loop will be used to make recursive calls).

###########################################################################################################################################################

path.append() return None and do changes in same List, path + [num] --> creates new list

Conceptually you can index a Python string like an array of characters, but under the hood it is **not** the same as a C/C++ `char[]`.

## Conceptual behavior
- Python strings are *sequences* of Unicode characters and support indexing and slicing: `s[0]`, `s[1:3]`, iteration in `for ch in s`, etc., 
   similar to an array of chars at the API level.[1][2]
- Unlike C/C++, there is no separate `char` type; a “character” is just a string of length 1, e.g. `'a'` is a `str`.[3][1]

## Implementation differences vs C/C++
- In C/C++: strings are typically contiguous `char` arrays terminated by `'\0'`.[4]
- In Python: `str` is an immutable object storing Unicode code points, not a raw `char[]`; the internal representation 
  is an implementation detail and not exposed as a modifiable character array.[5][3]
- Because strings are immutable, operations like concatenation or replace create a **new** string rather than modifying an 
  underlying buffer in place.[5][3]

So: you can think of a Python string as an indexable sequence of characters like an array, but it is a higher-level immutable Unicode string type,
not a low-level `char[]` as in C++.

Here are concise notes comparing swapping in **strings** vs **lists** in Python.

## Strings (immutable)

- Strings cannot be modified in place; attempting `s[0] = 'x'` gives `TypeError: 'str' object does not support item assignment`.[1][2]
- So code like:

  ```python
  arr = "123"
  arr[0], arr[2] = arr[2], arr[0]   # ❌ error
  ```

  is invalid because it tries to assign to string indices.[2][1]
- To “swap characters”, convert to a list, modify, then build a new string:

  ```python
  arr = "123"
  lst = list(arr)          # ['1', '2', '3']
  lst[0], lst[2] = lst[2], lst[0]
  arr = "".join(lst)       # "321"
  ```

## Lists (mutable)

- Lists are mutable, so you can freely change and swap elements in place.[3]
- Swapping two elements uses multiple assignment:

  ```python
  arr = [1, 2, 3]
  arr[0], arr[2] = arr[2], arr[0]   # [3, 2, 1]
  ```

- Any reference to the same list sees the updated order, because the list object itself is modified, not recreated.[4][3]

